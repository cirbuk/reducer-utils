import { ReduxAction, PatchStateOptions, BatchedReducerOptions, AnyAction, Reducer } from "./interfaces";
import { get, isString, isPlainObject, isUndefined, set, isNull } from "@kubric/litedash";
import { ActionTypes } from "./combinereducers";

export { default as combineReducers } from './combinereducers';

/**
 * Accepts an array of reducers and a default state and returns a single reducer. Any incoming action to the final
 * reducer passes through all the reducers(from left to right). The state passed to a reducer will be the state
 * generated by the reducer on its left
 * @param reducers
 * @param defaultState
 */
export const composeReducers = (reducers: Array<Reducer<any>> = [], defaultState: any): Function =>
  (state: any = defaultState, action: AnyAction = { type: ActionTypes.INIT }, ...extraArgs: any[]) =>
    reducers.reduce((state: any, reducer: Reducer<any>) => reducer(state, action, ...extraArgs), state);

/**
 * Accepts a reducer and returns a new reducer that is capable of handling a batch of actions and evaluating them in
 * as single state update
 * @param reducer
 * @param type
 * @param payload
 */
export const batchedActionReducer = (
  reducer: Function,
  {
    type = "BATCHED_ACTION",
    payload: payloadPath = "payload"
  }: BatchedReducerOptions = {}
): Function =>
  (state: any, action: ReduxAction = {}) => {
    if(action.type === type) {
      let payload = get(action, payloadPath, []);
      if(!Array.isArray(payload)) {
        payload = [payload];
      }
      return payload.reduce(reducer, state);
    } else {
      return reducer(state, action);
    }
  };

const patchByType = (
  src: string | Array<any> | object,
  dest?: string | Array<any> | object,
  at?: number | undefined
) => {
  const error = new Error(`source and destination types do not match`);
  const isDestUndefined = isUndefined(dest);
  const isAtUndefined = isUndefined(at);
  !isDestUndefined && (dest = JSON.parse(JSON.stringify(dest)));
  // @ts-ignore
  let parsedAt: number = isAtUndefined ? -1 : isNaN(+at) ? -1 : +at;
  if(isString(src)) {
    isDestUndefined && (dest = '');
    isAtUndefined && (parsedAt = (src as string).length);
  } else if(Array.isArray(src)) {
    if(isDestUndefined) {
      dest = []
    } else if(!Array.isArray(dest)) {
      dest = [dest];
    }
    if(parsedAt > src.length) {
      dest = [
        ...(new Array(parsedAt - src.length)),
        ...(dest as Array<any>)
      ];
    }
    isAtUndefined && (parsedAt = src.length);
  } else if(isPlainObject(src)) {
    isDestUndefined && (dest = {});
    parsedAt = -1;
  } else {
    throw error;
  }
  if(isString(src) && isString(dest)) {
    return `${(src as string).slice(0, parsedAt)}${dest}${(src as string).slice(parsedAt)}`;
  } else if(Array.isArray(src) && Array.isArray(dest)) {
    return [
      ...src.slice(0, parsedAt),
      ...dest,
      ...src.slice(parsedAt)
    ];
  } else if(isPlainObject(src) && isPlainObject(dest)) {
    return {
      ...(src as object),
      ...(dest as object),
    }
  } else {
    throw error;
  }
};

/**
 * Patches the state with a value doing a shallow clone
 * @param state
 * @param options
 * @param patch
 */
export const patchState = (
  state: any,
  patch: any,
  options: PatchStateOptions | string = {}
) => {
  if(isString(options)) {
    options = {
      path: options
    } as PatchStateOptions;
  }
  const { path = '', at: insertAt } = options as PatchStateOptions;
  if(isUndefined(patch)) {
    return state;
  } else if(isNull(path) || path.length === 0) {
    return patchByType(state, patch, insertAt);
  } else {
    const pathBeforeLast = path.split('.');
    const lastPath = pathBeforeLast.pop();
    let newState = patchByType(state);
    let statePointer: any = newState;
    let currentPath = pathBeforeLast.shift();
    while(!isUndefined(currentPath)) {
      const nextPath = pathBeforeLast.length > 0 ? pathBeforeLast[0] : lastPath;
      // @ts-ignore
      const isArray = !isNaN(+nextPath);
      set(statePointer, currentPath, patchByType(statePointer[currentPath as string] || (isArray ? [] : {})), {
        create: true
      });
      statePointer = statePointer[currentPath as string];
      currentPath = pathBeforeLast.shift();
    }
    const currentData = get(state, path, {});
    set(newState, path, patchByType(currentData, patch, insertAt));
    return newState;
  }
};